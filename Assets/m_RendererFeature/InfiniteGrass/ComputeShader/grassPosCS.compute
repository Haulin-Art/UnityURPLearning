#pragma kernel CSMain

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// ===================== 从C#脚本传入的变量 =====================
float _spacing;                 // 草地采样间距
float _drawDistance;            // 草地绘制距离
float _textureUpdateThreshold;  // 纹理更新阈值
//float _fullDetailDistance;      // 细节全开的距离
int2 _gridStartIndex;           // 采样网格起始索引
int2 _gridSize;                 // 采样网格尺寸
float3 _camPosition;            // 主摄像机位置
float2 _centerPos;              // 纹理渲染的中心点
float3 _boundsMin;              // 采样区域包围盒最小点
float3 _boundsMax;              // 采样区域包围盒最大点
float4x4 _VPMatrix;             // 主摄像机的视图投影矩阵
float4x4 _VMatrix;              // 主摄像机的视图矩阵
float _extraDistanceRemoval;    // 额外的距离剔除

// 采样器状态：线性过滤 + 纹理坐标钳位（0~1 范围，避免采样到纹理外）
SamplerState linearClampSampler;

// 从 URP RendererFeature 传递的纹理（GPU 端纹理资源）
Texture2D<float2> _grassHeightTex;  // 草地高度纹理（R 通道存储高度信息,G 通道存储草生长区域标记）
Texture2D<float> _CameraDepthTexture;

// GPU 端缓冲区
// AppendStructuredBuffer：GPU 端追加缓冲区，支持动态添加数据，带计数器（记录元素数量）
// 存储类型：float3（草的世界位置 X/Y/Z）
AppendStructuredBuffer<float3> _GrassPositions;


// 分段储存
RWStructuredBuffer<float3> _SegmentedBuffer;
RWStructuredBuffer<uint> _Counters; // 不同类型的实例数量的计数器
// 线程组内的共享变量，这里可以理解为每个小组内的计数，最终会统计所有小组
groupshared uint localCounter[2]; // 本线程各类型的数量
groupshared uint offset[2]; // 本组内的索引偏移量


// ====================================== 辅助函数：哈希函数（生成伪随机数） ======================================
// MurmurHash3 哈希算法（简化版）：将整数输入转换为无符号整数哈希值，用于生成均匀的伪随机数
uint murmurHash3(int input) {
    uint h = abs(input);          // 取输入的绝对值（避免负数）
    h ^= h >> 16;                 // 右移16位后异或，打乱高位
    h *= 0x85ebca6b;              // 乘以大质数，增加随机性
    h ^= h >> 13;                 // 右移13位后异或
    h *= 0xc2b2ae3d;              // 乘以另一个大质数
    h ^= h >> 16;                 // 最终异或，得到最终哈希值
    return h;
}
// ====================================== 辅助函数：生成0~1的伪随机数 ======================================
// 输入：索引值（网格的X/Z索引），输出：0~1的浮点数随机数
float random(int index)
{
    // 将哈希值除以 uint 的最大值（4294967295=2^32-1），得到0~1的浮点数
    return murmurHash3(index) / 4294967295.0;
}
// ====================================== 辅助函数：数值重映射 ======================================
// 将输入值从 [InMinMax.x, InMinMax.y] 映射到 [OutMinMax.x, OutMinMax.y]
float Remap(float In, float2 InMinMax, float2 OutMinMax)
{
    return OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
}


// [numthreads(8, 8, 1)]：定义线程组的大小（X=8，Y=8，Z=1）
// 每个线程组包含 8*8*1=64 个线程，GPU 会按线程组调度（需与 C# 端的 Dispatch 线程组数匹配）
// SV_DispatchThreadID：当前线程的全局ID（唯一标识，对应网格中的位置）
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID , uint3 localID : SV_GroupThreadID , uint groupIndex : SV_GroupThreadID )
{
    bool enable = false ; // 确定本线程计算出的位置是否加入
    float3 finalPos = float3(0,0,0); // 最终位置
    uint localIndex = 0 ; // 可用的数据的本组内的索引
    uint type = 0; // 本数据的类型
    
    // 初始化局部计数,只在开头的索引执行
    if (groupIndex == 0)
    {
        localCounter[0] = 0;
        localCounter[1] = 0;
    }
    // 等待本线程组内的所有线程到达完成这一步
    GroupMemoryBarrierWithGroupSync();




    // 1. 计算当前线程对应的草地网格索引（全局索引 = 网格起始索引 + 线程ID的XY分量）
    int2 currentIndex = _gridStartIndex + id.xy;
    // 2. 计算草的初始XZ世界位置（网格索引 * 草间距 = 基础位置）
    float2 positionXZ = currentIndex * _spacing;
    // 3. 添加随机偏移（避免草排列过于整齐，增加自然感）
    // 生成两个随机数（基于网格索引，保证同一位置的随机数固定）
    float2 randomOffset = float2(
        random(currentIndex.x * 5542 + currentIndex.y),  // X偏移随机数（5542是随机质数，打乱索引）
        random(currentIndex.y * 9824 + currentIndex.x)   // Y偏移随机数（9824是随机质数）
    );
    // 将随机数从0~1映射到-~Spacing~+Spacing，叠加到初始位置
    positionXZ += (randomOffset * 2 - 1) * _spacing;

    // 4. 计算高度图/掩码图的采样UV坐标（归一化到0~1范围）
    // 步骤：(世界位置 - 纹理中心位置) / 纹理范围（绘制距离+更新阈值）→ 映射到-1~1 → 再映射到0~1
    float2 uv = (positionXZ - _centerPos) / (_textureUpdateThreshold + _drawDistance); 
    uv = uv * 0.5 + 0.5;  // 从[-1,1]映射到[0,1]

    // 5. 采样高度图纹理（SampleLevel：指定mipmap层级为0，即最高分辨率）
    // heightMap.r：高度值（0~1），heightMap.g：草生成区域标记（1=允许，0=禁止）
    float2 heightMap = _grassHeightTex.SampleLevel(linearClampSampler, uv, 0).rg;
    // 处理，让最外层一圈为纯黑色
    float mask = (1.0-step(0.99,2.0*abs(uv.y-0.5)));//*(1.0-step(0.1,2.0*abs(uv.y-0.5)));
    mask *= (1.0-step(0.99,2.0*abs(uv.x-0.5)));
    heightMap *= mask;

    // 6.0 遮罩密度信息，后续可以添加，这里只是设定为 0
    //float maskValue = 0.0;

    // 7. 掩码密度筛选：根据掩码值和随机数判断是否生成草（实现密度控制）
    // 逻辑说明：
    // - maskValue=0 → 随机数≥0 → 始终生成草（全密度）
    // - maskValue=1 → 随机数≥1 → 永不生成草（无草）
    // - maskValue=0.5 → 50%概率生成草（半密度）
    // saturate：将值限制在0~1；-0.001是避免随机数刚好等于1的极端情况
    //bool inMask = saturate(random(currentIndex.x * 9421 + currentIndex.y) - 0.001) >= maskValue;

    // 8. 高度图区域筛选：只有高度图G通道为1（允许生成）且掩码筛选通过，才继续处理
    if (step(0.001,heightMap.r) == 1)
    {
        // 9. 重构草的世界Y坐标（将高度图的0~1值映射到相机包围盒的Y轴范围）
        float positionY = Remap(heightMap.r, float2(0, 1), float2(_boundsMin.y, _boundsMax.y));

        // 10. 组合草的完整世界位置（X=positionXZ.x，Y=positionY，Z=positionXZ.y）
        float3 positionWS = float3(positionXZ.x, positionY, positionXZ.y); 
        float distanceFromCamera = length(_camPosition - positionWS);
        // 11. 距离密度筛选：根据与相机的距离降低草的密度（性能优化）
        // 这个之后添加，适用于根据相机距离随机剔除一些草，离得越远剔除概率越大，以达到优化性能
        float disMaskValue = smoothstep(0.0*_drawDistance,_drawDistance,distanceFromCamera);
        disMaskValue = pow(disMaskValue,0.3);
        //disMaskValue *= disMaskValue*disMaskValue;
        bool inDisLevel = saturate(random(currentIndex.x * 9421 + currentIndex.y) - 0.001) >= disMaskValue;

        // 12. 密度级别筛选通过，继续视锥体裁剪
        if (inDisLevel )
        {
            // 13. 视锥体裁剪（简化版，来自Colin Leung的优化方案）
            // 原理：将世界位置转换为裁剪空间坐标（w分量是齐次坐标），通过判断坐标范围实现裁剪
            float4 clipPos = mul(_VPMatrix, float4(positionWS, 1.0)); // 世界空间→裁剪空间
            float4 absPosCS = abs(clipPos); // 取绝对值，简化裁剪判断

            float4 viewPos = mul(_VMatrix, float4(positionWS, 1.0)); // 转换到视图空间
            // 设置遮挡剔除参数 正确的屏幕UV计算
            float2 ndc = clipPos.xy / clipPos.w;  // 转换为NDC坐标[-1, 1]
            float4 screenPos = ComputeScreenPos(clipPos);
            float2 screenUV = screenPos.xy / screenPos.w;
            // 处理平台差异：Y轴可能翻转
            #if UNITY_UV_STARTS_AT_TOP
                screenUV.y = 1.0 - screenUV.y;
            #endif
            screenUV = clamp(screenUV,0.0,1.0);

            // 正确的深度比较：
            // 1. 使用视图空间的深度（viewPos.z是负值，取绝对值）
            float grassDepth = -viewPos.z;  // 相机空间线性深度
            //grassDepth = length(positionWS-_camPosition);

            float depthMap = _CameraDepthTexture.SampleLevel(linearClampSampler,screenUV/1.0,0);
            depthMap = LinearEyeDepth(depthMap,_ZBufferParams);
            
            // 裁剪条件（宽松裁剪，避免边缘草被过度裁剪）：
            //if (absPosCS.z <= absPosCS.w && absPosCS.y <= absPosCS.w * 1.5 && absPosCS.x <= absPosCS.w * 1.1 && absPosCS.w <= _drawDistance)；
            if (absPosCS.z <= absPosCS.w *1.2 && // 这个不知道，好像改了效果不明显
                absPosCS.y <= absPosCS.w  * 1.5&& // 纵深近处剔除
                absPosCS.x <= absPosCS.w  * 1.1 // 视线角度 
                
                //&& grassDepth <= depthMap
                //&& depthMap <= 10.0 // 遮挡剔除
                //&& grassDepth <= 50.0 // 遮挡剔除
                //&& grassDepth <= _extraDistanceRemoval // 额外的距离剔除
                )
                
            {
                // 到这里是所有可用的位置，开始判断类型
                // 我这里简单的用比例确定不同类型，类型A占30%，类型B占70%
                // 根据类型后会获取在本组内的唯一索引
                //uint myLocalNumber = 0;  // 我在本组内的排队号
                float rate = saturate(random(currentIndex.x * 9421 + currentIndex.y) - 0.001);
                if (grassDepth < 10.0)
                {
                    type = 0;
                    InterlockedAdd(localCounter[type], 1, localIndex);
                    // InterlockedAdd(A,B,C) 这个函数相当于这样运算 先计算 C = A + B ，之后 A = A + B 
                }else
                {
                    type = 1;
                    InterlockedAdd(localCounter[type], 1, localIndex);
                }
                enable = true;
                finalPos = positionWS;


                // 14. 所有筛选通过，将草位置追加到缓冲区
                _GrassPositions.Append(positionWS); // 这里是原始的，这里先不改
            }
        }

    }

    
    // 等待所有通过的完成
    GroupMemoryBarrierWithGroupSync();


    // 获取全局唯一索引
    if (groupIndex == 0) 
    {
        uint prevCountA, prevCountB ;
        InterlockedAdd(_Counters[0], localCounter[0], prevCountA);
        InterlockedAdd(_Counters[1], localCounter[1], prevCountB);

        offset[0] = prevCountA;
        offset[1] = prevCountA + prevCountB ;
    }
    GroupMemoryBarrierWithGroupSync();
    
    if (enable)
    {
        uint globalIndex = 0; // 全局索引

        if (type == 0 )
        {
            globalIndex = offset[0] + localIndex;
        }else{
            globalIndex = offset[1] + localIndex;
        }
        _SegmentedBuffer[globalIndex] = finalPos;
    }
    
}
